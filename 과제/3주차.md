## 3주차 : 리팩터링 카탈로그 보는 법 / 기본적인 리팩터링
--------------------------------------------------
2. 6장에서 배운 리팩터링 기법(총 11개)들 간에는 연간관계가 있습니다.   예를들면 a와 b는 서로 반대되는 작업으로 묶일 수 있고, c, d는 e를 위한 사전단계로서 의미가 있습니다.
이러한 기법들간의 관계에 대해 발견한 바를 정리해서 작성해보세요. (500자 이상)		

* (1) 반대되는 작업
    - 함수 추출하기 - 함수 인라인하기 
<br /> -> 목적과 구현이 분리되지 않을 때는 함수 추출하기 기법을 이용하여 분리될 수 있도록 리팩터링해준다. 반대로 함수의 본문이 이름만큼 명확할 때는 굳이 함수로 두지 않고 인라인 리팩터링을 진행하면 된다. 
    - 변수 추출하기 - 변수 인라인하기 
<br />-> 표현식이 너무 복잡하여 이해하기 힘들 때는 변수 추출하기 기법을 사용하고, 변수 이름이 표현식과 다를바가 없을 때는 변수 인라인하기로 코드를 줄인다. 변수로 추출되지 않은 복잡한 표현식은 이해하기 어렵고, 너무 많은 표현식이 변수화되어있을 때도 리팩터링을 진행하기 힘들기 때문에 표현식이 간결해지는 지점에서 추출 / 인라인 기법을 사용하면된다. 
    - 여러 함수를 클래스로 묶기 - 여러 함수를 변환함수로 묶기 
<br />-> 반대되는 작업이라기 보다는, 상황에 따라 둘 중 하나의 작업이 진행되기 때문에 반대 카테고리에 넣었다. 하지만 상황에 따라 적절한 작업이 선택된다. 원본 데이터가 코드 안에서 갱신이 될 때는 클래스로 묶는 편이 좋고, 갱신되지 않을 때는 변환함수로 묶기 작업을 수행하면 된다.
* (2) 사전단계 작업
    - 단계 쪼개기의 사전단계 : 함수 추출하기 , 매개변수 객체 만들기 
<br />-> 서로 다른 두 대상을 한꺼번에 다루는 코드를 각각 별개의 모듈로 나누는 리팩터링을 진행할 수 있다. 이 때, 하나의 대상을 독립적인 함수로 추출하기 기법을 사용하여 나누는 사전 작업이 진행된다. 또한, 독립된 두 함수가 공유하는 변수를 인수로 추가할 때, 매개변수가 복잡하고 서로 연관관계를 가질 때는 객체로 만들어서 단순화한다. 
    - 변수 이름 바꾸기의 사전단계 : 변수 캡슐화하기
<br />-> 변수 이름을 적절하게 바꾸기 전에는 우선 변수가 폭넓게 쓰이는지 판단하여 캡슐화를 사전에 진행할지 고려한다.
    - 함수 선언 바꾸기의 사전단계 : 함수 추출하기, 함수 인라인하기 
<br />-> 함수 선언 변경은 까다로운 작업이다. 따라서 마이그레이션 절차가 필요할 때가 많다. 함수 본문을 새로운 함수로 단계별 추출한 후, 예전 함수를 인라인한다. 예전 함수를 호출하는 모든 부분이 새 함수 호출로 변경되고, 모든 단계에서 테스트가 제대로 동작하면 기존 함수를 삭제하는 단계로 절차가 마무리된다. 따라서 함수 추출하기와 인라인하기 기법이 사용된다.
--------------------------------------------------
3. 함수 추출하기를 행하는 이유로 가장 중요한 한가지, 한 문장을 적으시오.
<br />목적과 구현의 분리
--------------------------------------------------
4. 아래의 코드를 확인하고 리팩터링 하시오. 사용한 기법과, 해당 기법을 어디에 사용했는지 서술하시오.
사용한 기법
 - 변수 캡슐화하기 : 다방면에서 이용되는 변수 travels와 accommodations를 캡슐화하여 함수로 도출하였다. 함수는 데이터보다 다루기 수월하기 때문에, const 형태의 데이터로 두는 것보다 함수로 리팩터링하는 것이 더 좋다고 생각했기 때문이다.
 - 변수 이름 바꾸기 : 의도하신지는 모르겠으나 , accomodations으로 정의되어 있는 변수를 accommodations으로 스펠링을 고쳐 리팩터링하였다.
 - 함수 추출하기 : travels와 accommodations 내용을 프린트하는 부분을 함수 추출하기 기법을 사용하여 리팩터링하였다. 
 - 여러함수를 변환함수로 묶기 : 환불금액을 계산하는 부분을 변환함수로 묶어서 내부적으로 호출하여 코드를 줄였다. 
 - 함수 추출하기 : 변환함수로 묶인 계산식을 함수 추출하여 계산 결과만 반환하도록하였다. 파라미터화를 통하여 중복되는 코드를 줄여 한 함수가 처리하도록 리팩터링하였다.
 - 함수 인라인하기 : 변환함수로 묶인 계산식의 결과를 리턴할 때, 계산 결과를 변수로 받고, 그 변수를 반환하는 코드를 인라인하여 아예 계산 결과 자체를 반환하도록 함수 인라인하였다. 
<br />이렇게 모든 함수가 하나의 처리만 진행하도록 목적과 구현을 분리하려고 노력하면 리팩터링을 진행하였다. 
--------------------------------------------------
5. 본 챕터에는 단순히 코드를 변경하는 기법 이외에도 저자의 견해가 여럿 서술되어 있습니다. 이 중 자신의 기존 관념과 가장 달랐던 저자의 생각을 쓰세요. 혹은 만일 그런게 없다고 하면, 자신의 기존 리팩터링 사고와 가장 잘 닿는 바를 적으세요. (300자 이내)		
* 저자는 변수 캡슐화하기 (p.189)에서 객체 지향의 객체는 데이터를 항상 private으로 유지해야 한다고 ‘그토록’ 강조한다.
<br/>물론 객체 지향에서 객체의 캡슐화 등을 위해 필드의 접근을 제한해야한다는 것이 기본 관념인 것은 알고 있지만 최근 언어의 트렌드에 비추어 봤을 때 객체의 데이터 은닉이 유용하게 사용되는가 의문을 던진다.
<br/>자바의 경우 reflection 등의 기능으로 마음만 먹으면 private한 필드에 접근이 가능해졌다. 따라서 접근제한자가 선언적인 의미를 가질 수는 있어도 실제 유용성은 떨어진다는 생각이다. 개발자 개개인이 해당 객체의 데이터 접근 / 수정을 지양하도록 규약하고 이를 지킬 수 있는 문화를 만드는 것이 더욱 중요하다고 생각한다. 




