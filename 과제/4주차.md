## 4주차 : 캡슐화
--------------------------------------------------
1. 컬렉션이나 레코드의 게터/세터, 그리고 가변데이터와 관련된 문제가 무엇이고 그 해결책을 설명하시오. (자유분량 / 20점)	
* 컬렉션이나 레코드의 게터/세터, 가변데이터와 관련된 문제 중 가장 큰 문제는 데이터를 누군가가 쉽게 수정할 수 있다는 것이다. 
<br/>게터 함수를 이용하여 원본 데이터를 얻은 후 해당 데이터/주소값을 변경할 수 있고, 세터를 이용해서도 클라이언트가 마음대로 수정할 수 있다. 불변 데이터일 때는 쉽게 수정할 수 없지만 가변데이터일 때는 데이터 변경이 쉽고 이를 추적하기 쉽지 않다는 문제가 있는 것이다.
<br/>이렇게 컬렉션/레코드 값을 쉽게 변경할 수 있는 문제를 해결하기 위해서는 다양한 방법이 있다. 우선 게터 메소드를 이용하여 해당 컬렉션/레코드에 접근할 때, 원본 데이터를 주는 것이 아니라 복제본을 제공하는 해결책을 사용한다. 
<br/>세터 메소드는 기본적으로 제공하지 않고, 컬렉션의 경우 개별 원소를 추가/제거/변경할 수 있는 메소드를 제공하여 보다 안전하게 데이터 수정이 일어날 수 있게 해결한다. 혹시라도 세터 메소드가 꼭 필요한 경우라면 컬렉션의 복제본을 필드에 저장하게 하여 어느정도 안전함을 지킬 수 있게 한다. 불필요한 복제본을 남용한다는 느낌이 들 수 있지만, 데이터 수정을 추적하기 어려워 관리가 힘든 소스보다는 복제본이 많은 상태가 더 경제적일 것이다. 
<br/>이렇게 가변 데이터 접근을 캡슐화함으로써 데이터 일관성이 깨지는 것을 막을 수 있다. 이 때, 클라이언트에게 데이터 수정시 에러를 던지거나 읽기전용 프락시를 제공하여 특정 메소드를 통하지 않으면 수정할 수 없음을 알려준다.
--------------------------------------------------
2. ‘기법’들 중에는 다소 무의미한 방법들이 설명되곤 한다. 이번 7장의 기법 ‘절차’ 들 중에 가장 필요없는 설명이 들어간 절차를 찾으시오. (자유분량 / 10점)
* 알고리즘 교체하기 기법이 가장 무의미한 기법이 아닌가 싶다.
일단 캡슐화 챕터에서 알고리즘 교체 기법이 포함된 연관관계가 명확하게 이해되지 않는다. 
<br/>또한 알고리즘을 어떻게 교체할 것인지의 구체적인 내용이 들어간 절차가 아니라 그저 더 좋은 알고리즘이 있다면 변경한다는 다소 추상적인 기법을 제시하는 것 같아서 그렇게 생각한다. 
<br/>물론 리팩터링 기법 중에서는 중요한 요소라고 생각되지만 이 챕터와의 연관성과 절차 설명에 대한 구체성이 떨어져서 가장 의미가 적은 기법이라고 선택하게 되었다. 
--------------------------------------------------
3. “기본형을 객체로 만들기“ 기법과 어울리는 악취가 무엇인지, 객체로 표현하는게 유리하지만 기본형으로 표현하는 경우가 잦은 예시를 하나 찾아 서술하시오.	
* 기본형을 객체로 만들기 기법에서 떠오르는 악취는 기본형 집착 악취이다. 
대표적으로 떠오르는 예시는 대한민국 국민이라면 모두 가지고 있는 주민등록번호를 꼽을 수 있을 것 같다. 
<br/>주민등록번호는 모두 숫자로 이루어진 고유번호이기 때문에 숫자 기본형으로 표현되기도 하고, 앞 6숫자와 뒤 7숫자를 구분하는 -(dash)를 포함하기 위해 문자열로 표현되기도 한다. 소위 책에서 말하는 ‘문자열화된(stringly typed) 변수’의 대표적인 사례이다.  
<br/>하지만 주민등록번호는 각 자리의 의미가 뚜렷하고, 가끔은 각 자리의 고유 정보를 필요로 할 때가 있다. 예를 들어 성별을 구분하거나(물론 생물학적 성별만 구분할 수 있기에 주민등록번호의 한 자리의 숫자로만 성별을 도출한다면 문제가 생길수도 있다.) 공식적인 나이, 생일을 판단하는 등의 정보를 도출할 수 있는 값인 것이다.
<br/> 이렇게 많은 정보가 담겨있는 주민등록번호를 기본형으로 만들게 되면 각 자리의 정보가 필요할 때마다 파싱하여 가져와야하는 번거로움이 따른다. 
따라서 주민등록번호를 객체로 표현하여 각 자리의 고유 데이터를 편리하게 추출하고, 사용자에게 정보를 줄 대도 일관된 형식으로 출력할 수 있도록 리팩터링하는 것이 좋을 것 같다. 
<br/> 실무에서 주민등록번호를  기본형으로 취급하는 경우를 많이 보았다. 많이 나아진 상태가 -(dash)를 기준으로 두 문자열 변수로 나눠 담는 경우인데, 이 또한 제대로 된 구조라고 생각하지 않는다. 두 문자열 변수로 나눠 기본형 표현하는 것이 아니라 합쳐진 하나의 캡슐화된 객체로 표현하는 것이 훨씬 깔끔하고 편리하다고 생각한다.
--------------------------------------------------
4. 다음을 리팩터링 하시오
* 클래스 추출하기
    Person 객체에서 사용하는 treatments 정보를 하나의 클래스로 추출하였다.
	<br/> 이를 통해 treatment 객체 고유의 date, 백신 맞을 수 있는지 여부를 return하는 메소드를 구현하였다. 
	<br/>treatment 정보를 클래스로 추출함으로써  각 사람의 treatments 리스트를 관리하기 쉽게 리팩터링하였다. 
	<br/>즉 한 사람이 지금까지 치료해 온 목록을 추적하기 쉬워지도록 각 치료 정보를 캡슐화하였다.
* 위임 숨기기
	<br/> VaccinationRecord 클래스의 isImmune 메소드를 Person 객체에 위임 메소드를 생성하였다 
	<br/> VaccinationRecord에 접근하지 않고 직접 면역을 얻었는지 확인할 수 있는 함수 생성하여
	<br/>이러한 캡슐화를 통해 클라이언트는 위임 객체를 알 필요가 없어지며 위임 객체를 변경하기 용이해진다.
* 알고리즘 교체하기
    <br/>for문을 돌려 cannotJab 메소드 결과가 true값이 있는지 확인하는 함수를 iterator 사용하여 루프문을 간단하게 리팩터링하였다.
	<br/> record 중 cannotJab 메소드의 true값, 즉 백신 결격사유가 있다는 리턴이 하나라도 있다면 최종적으로는 백신 맞을 준비가 되지 않은 것이다.
    <br/>따라서 record의 결격사유들을 순환하여 cannotJab의 true값이 하나라도 발견된다면 false를 리턴하도록 some()메소드로 검사하도록 알고리즘을 교체하였다.

--------------------------------------------------
5. 캡슐화는 OOP의 핵심 패러다임중 하나다. 일반적으로는 클래스와 연관지어 설명되곤 하지만, 본 책에서는 객체화와는 별개로 캡슐화를 사용한다.
 예를들어 변수 캡슐화가 대표적이다. 강요된 oop가 아닌 언어로 개발해본 경험이 있다면 이와 관련해 어떤 불편함이 있었는지. 
강요된 oop가 아닌 언어로 개발할 때 캡슐화 생성시 불편함이 없었다면 굳이 강요된 oop가 아닌 요소를 사용할 이유가 있는지, 개인의 생각을 서술하시오. 
* 강요된 oop가 아닌 언어로 개발을 한 경험은 인프라를 구성할 때 해보았다.
<br/>복잡한 아키텍처는 아니었지만 Nginx로 프록시 서버를 C언어로 개발하였고, 쉡 스크립트 언어로 CI/CD 파이프라인을 생성해보았던 경험이 있다. 
<br/>이 과정에서 캡슐화된 요소를 사용하지 않아서 생기는 불편함은 꽤 많았던 것같다. 쉘 스크립트 전체 소스에서 접근/수정하는 변수가 존재함에도 캡슐화하지 않아서 해당 변수를 변경하는 지점을 찾아야 할 때 디버깅 과정이 복잡했던 경험이 있다. 하지만 모든 변수를 캡슐화하는 것은 합리적이지 못한 작업이라고 생각했는데 꼭 oop언어가 아니더라도 캡슐화해야 안전한 데이터는 리팩터링을 해야겠다는 생각이 들었다. 
<br/>확실히 oop언어가 구조적으로 접근하기 쉬워 유지보수에 도움이 되는 것같다. oop언어가 아닐지라도 객체지향의 좋은 속성들을 접목해보아야겠다.
