## 2주차 : 코드에서 나는 악취 / 테스트 구축하기
--------------------------------------------------
1. 함수의 이름을 짓는 방법과 관련하여 책에 서술된 조언을 쓰시오 (500자 이상)		
* 함수의 이름을 짓는 방법에 대한 저자의 조언으로는 단순하고 명료하게 작성하는 것이다. 코드를 명료하게 표현하는 데 가장 중요한 요소는 이름이기 때문에 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 엄청나게 신경을 써서 이름을 지어야 한다.
<br /> 이름을 잘 짓는 것은 프로그래밍에서 손 꼽히는 어려운 일이다. 함수 선언 바꾸기를 포함한 변수 이름 바꾸기, 필드 이름 바꾸기 등 다양한 이름 변경 리팩터링이 가장 많이 발생하는 리팩터링 중 하나이다. 
<br /> 이렇게 어렵고 자주 발생하는 리팩터링인 함수명 변경은 단순히 이름을 다르게 표현허는 연습이 아니기 때문에 적절한 이름을 찾기 위해 노력해야한다. 적절한 이름이 마땅히 떠오르지 않는다면 더 근본적인 문제가 숨어 있을 가능성이 높다. 따라서 혼란스러운 이름을 잘 정리하게 되면 본문에 숨어 있는 악취를 발견할 수 있고, 이러한 부분을 해결하는 흐름을 탈 수 있기 때문에 코드가 훨씬 간결해 질 수 있다.
<br />함수의 이름을 읽고 즉각 의미가 와 닿지 않거나 이해하기 힘들다면 함수명을 변경해야 한다. 좋은 이름을 짓기 위한 책의 팁은 주석을 이용하여 함수의 목적을 설명해보는 것이다. 그렇게 주석을 짓다보면 멋지고 이해하기 쉬운 함수명으로 돌아올 수 있다.
--------------------------------------------------
2. 책에 제시된 악취들 중 YAGNI와 가장 잘 어울리는 항목은 무엇인가(500자 이상)		
* YAGNI는 간결한 설계, 점진적 설계라고 불리는 설계 방식이다. 즉, 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축하는 방식이다. 
<br />이와 관련한 악취는 추측성 일반화(Speculative Generality)이다. 굉장히 민감하게 반응해야 하는 악취이다. 나중에 필요할거라는 생각으로 생성한 당장은 필요없는 로직과 예외처리를 의미한다. 이렇게 미리 작성해 둔 코드는 이해하기 어렵고 관리하기 어려워진다. 이러한 악취를 해결하기 위한 방법은 여러가지가 있다. 
<br /> 만약 필요치 않은 추상 클래스가 너무 많이 존재한다면 계층 합치기 방법으로 필요없는 추상 클래스들을 제거할 수 있다. 
<br />계층 합치기란 부모 클래스와 자식 클래스가 따로 존재하지 않아도 될 때 하나의 클래스로 합치는 방법을 의미한다. 또한 쓸데없이 다른 함수나 클래스를 생성하여 해당 로직이나 변수를 위임하고 있는 코드라면 함수 인라인하기, 클래스 인라인하기 방법으로 해결할 수 있다. 
이 방법은 따로 로직이 분리되어 있거나 독자적으로 존재하는 함수, 클래스를 제거하고 합치는 방법이다. 
<br />마지막으로는 함수 선언 바꾸기 방법을 이용하여 본문에서 사용하지 않는 매개변수를 제거하는 방법이 있다. 
<br />추가로, 의미있게 사용되지 않고 테스트 코드에서만 사용되는 함수를 제거하는 죽은 코드 제거하기 방법이 있다. 
--------------------------------------------------
3. 주석과 악취의 관계에 대해 서술하시오 (500자 이상)		
* 저자는 주석을 작성하는 것이 악취라고 말하지 않는다. 주석을 악취라고 보기보다는 오히려 향기를 입히는 좋은 습관이라고 말한다. 하지만 주석을 너무 장황하게 단다는 것은 코드가 잘못 작성되었거나 너무 크게 복잡하여 리팩토링 필요한 코드일 확률이 높다. 이를 덮기 위한 탈취제로 주석을 이용하는 경우가 많고 이는 문제라고 볼 수 있다. 주석이 많으면 악취가 많이 나는 코드가 나오기 쉽다. 이러한 코드를 리팩토링하게되면 주석이 필요하지 않고 코드만으로 이해가 가능한 상황이 발생할 확률이 높다.
<br />저자는 주석이 달린 코드를 리팩토링하는 방법을 몇가지 소개한다. 
<br />특정 블록이 하는 일에 주석을 달고 싶다면 해당 코드를 함수로 추출하여 주석을 제거할 수 있다. 
<br />추출을 완료한 함수에도 설명 주석을 달고 싶다면 함수 선언 바꾸기로 함수 이름을 변경해본다. 이름만으로도 해당 함수에 대해 설명이 되는 방향으로 변경해준다. 
<br />해당 시스템이 동작하기 위한 선행 작업을 설명하고 싶다면 어서션을 추가하여 해당 주석을 제거할 수 있다.
<br />주석을 달고 싶을 때는, 주석을 달기 전에 주석이 필요없는 코드로 리팩터링을 선행해보면 좋다. 
<br />주석이 필요한 경우는 확실하지 않은 부분이라거나, 뭘 해야할지 모르는 상황이거나 지금처럼 작성한 이유를 설명하고 싶은 상황이다. 이러한 주석은 프로그래머에게 도움이 되는 주석이다.
--------------------------------------------------
4. OOP 개념을 적극 적용하지 않아 함수와 변수들이 제각각 흩어진 코드가 있다. 이 들을 모아 하나의 클래스로 만들고 싶다. 이에 해당하는 ‘악취’에는 무엇이 있는가, 그 이유를 설명하라.(의도 답 : 데이터 뭉치, 산탄총 수술, 그러나 대부분의 예시가 제시된 리팩터링 과정에 적용 가능한 만큼, 설명이 충분히 설득력 있다면 점수 가능) (500자 이상)		
* 여기저기 흩어져있는 코드에 해당하는 악취는 산탄총 수술(Shotgun Surgery)이다. 
<br />이 악취는 뒤엉킨 변경이라 불리는 악취와 반대되는 악취이다. 맥락 구분이 제대로 이루어지지 않는다는 문제를 일으키고, 맥락을 정확히 구분되는 코드로 변경한다는 공통점이 있지만, 현상이 여러 코드에 흩뿌려진 산탄총 수술과 달리 뒤엉킨 변경은 한 코드에 섞여 들어간 것을 의미한다. 
<br />또한 해법도 뒤엉킨 변경은 맥락별로 분리를 해야하지만 산탄총 수술은 반대로 맥락에 따라 모아야 한다. 
<br />만약 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스, 함수가 너무 많다면 해당 악취를 의심해봐야 한다. 변경할 부분이 너무 많다면 찾기 어렵고 수정할 곳 지나치기 쉽기 때문이다. 이러한 문제를 해결할 방법으로는 함수 옮기기, 필드 옮기기를 이용해 연관된 코드를 모두 한 모듈에 묶는다. 데이터를 비슷하게 다룬다면 여러 함수를 클래스로 묶는 방법을 적용한다. 여러 함수를 변환 함수로 묶고 해당 결과를 다음 단계 로직으로 전달할 수 있으면 단계 쪼개기를 적용한다. 함수 인라인, 클래스 인라인으로 합치게 되면, 코드가 비대해지지만 리팩터링할 지점을 쉽게 찾을 수 있기 때문에 재구성을 위한 단계로 좋은 방법이다. 
<br /> 데이터 뭉치 또한 해당 악취라고 볼 수 있다. 필드 형태의 데이터 뭉치가 있다면 따로 클래스 추출하고, 매개변수가 너무 많고 연결성이 있다면 매개변수 객체 만들기를 적용한다. 이렇게 데이터 뭉치의 보금자리를 하나로 마련한다면 악취를 제거할 수 있다.
--------------------------------------------------	
5. 책에 제시된 악취들 중 서로 상충되는 두 악취를 한 쌍 고르고, 이 둘 사이에 적당한 지점을 찾는 법에 대해서 개인의 생각을 서술하시오. (500자 이상)		
* 개인적으로 책에 제시된 악취 중 대표적으로 상충되는 두 악취는 성의 없는 요소(lazy element)와 긴 함수(long function)이다.
<br /> 긴 함수는 이해하기 어렵기 때문에 지양해야한다. 짧은 함수가 끝없이 위임하는 방식이 훨씬 이해하고, 공유하고, 선택하기 쉽다. 간접 호출의 효과가 발휘되기 때문이다. 초창기에는 함수가 여러개 존재하게 되면 함수 호출 비용이 발생하기 때문에 고민이 있었다. 하지만 요즘 언어는 프로세스 안에서의 함수 호출 비용을 거의 없애버렸기 때문에 부담이 줄었다. 사람이 직접 호출 함수를 왔다갔다하는 부작용은 아직 있지만 IDE의 힘을 빌리게 되면 이러한 비용도 줄어들 수 있다. 따라서 우리는 함수를 적극적으로 줄일 필요가 있다. 함수를 설명할 수 있는 함수명을 가질 수 있도록 쪼개서 악취를 제거할 수 있다. 
성의 없는 요소는 필요 없고, 성의가 없는 프로그램 요소를 제거하는 방법이다. 함수, 클래스, 인터페이스 등 코드 구조를 잡는 요소를 프로그램 요소라고 하는데, 이러한 요소 중 필요 없거나 의미가 없거나 나누어져 있지 않아도 되는 요소가 존재한다. 이렇게 역할이 없는 요소들은 악취로 작용하기 때문에 고이 보내드리는 것이 좋다. 함수 인라인하기, 클래스 인라인하기, 계층 합치기 등의 방법으로 제거할 수 있다.
<br /> 잘 생각해 보면 두 악취는 상충되어 보인다. 긴 함수에서 저자는 끝없는 위임 방식으로 코딩을 해야 이해하기 쉽다고 말하지만 성의없는 요소는 절대 남겨서 안된다고 말한다. 하지만 개인적으로 이해하기로는 단일책임의 원칙을 지키는 선에서 함수를 쪼개는 것이 적당한 지점이라고 생각한다. 만약 하나의 책임이 아닌 여러 책임을 지고 있는 함수거나, 아키텍처에 따라 계층적으로 구분되어야 하는데도 뒤엉켜있는 코드라면 따로 떼어내는 것이 맞다고 생각한다. 이와 다르게 하나의 책임도 지지 않고 있는 요소라면 제거하는 것이 적절하다고 생각이 든다. 
<br /> 추가적으로 개인적으로 조금은 상충된다고 느껴지는 두 악취는 뒤엉킨 변경(Divergent Change)와 산탄총 수술(Shotgun Surgery)라고 생각한다. 두 악취는 서로 밀접한 악취이기에 비슷한 점도 많고 반대되는 점도 많다고 생각이 된다. 
<br /> 뒤엉킨 변경은 단일 책임 원칙(SRP)이 제대로 지켜지지 않은 악취이다. 한 모듈이 여러 이유로 변경되는 일이 많은 악취를 의미한다. 이러한 악취는 단계 쪼개기, 각 맥락에 맞게 함수 옮기기, 여러 맥락에 관여하는 함수 추출하기, 클래스 추출하기 등으로 해결할 수 있다.
<br /> 산탄총 수술은 연관된 코드 / 로직이 다양한 지점에 흩뿌려진 악취이다. 이러한 악취는 함수나 필드 옮기기, 여러 함수 클래스/변환 함수로 묶기, 함수/클래스 인라인하기로 리팩터링할 수 있다. 
<br /> 두 악취의 적당한 지점은 위의 두 악취의 지점과 마찬가지로 결국 코드를 수정할 때 시스템에서 고쳐야 할 딱 한 군데를 찾을 수 있어야 한다는 원칙을 지킬 수 있어야 한다고 생각한다. 만약 하나의 함수에 다양한 책임이 있어서 다양한 이유로 변경이 발생한다면 뒤엉킨 변경 악취가 나는 것이고, 하나의 문제점을 다양한 지점에서 변경해야 한다면 산탄총 수술 악취가 나는 것이라고 보아야한다. 결국 두 악취는 비슷한듯 하지만 완전히 다른 리팩터링 지점이기 때문에 제대로 구분이 가능하다고 생각을 한다.
<br /> 악취를 정리하면 
<br />하나의 버그/수정 사항 발생 -> 다양한 부분 변경해야 함 : 산탄총 수술 
<br />다양한 버그/수정 사항 발생 -> 하나의 지점만 변경하면 됨 : 뒤엉킨 변경
<br />리팩터링 결과로는
<br />하나의 버그/수정 사항 발생 -> 하나의 지점 변경
<br />다양한 버그/수정 사항 발생 -> 각 버그/수정 사항을 발생시키는 각각 하나의 지점 변경
<br />이라고 정리할 수 있다.
--------------------------------------------------
6. ‘가변 데이터’ 와 ‘전역 데이터’ 악취 각각에 대해, 그리고 가변 데이터가 동시에 전역 데이터인 악취에 대해 설명하시오. (500자 이상)		
* 가변 데이터는 불변 데이터와 달리 어디서든 값이 변경될 수 있다. 따라서 데이터 변경을 했을 때 예상치 못한 결과가 반환되거나 다른 코드에 영향을 미치게 되어 버그가 발생될 수 있다. 이러한 악취는 디버깅이 어렵고 시간이 오래 걸린다. 따라서 웬만하면 불변 데이터를 사용하거나 값을 복사해서 사용하는 습관을 들여야한다. 하지만 꼭 가변 데이터를 사용해야하는 상황도 있기 때문에 위험성을 줄일 수 있는 방법을 찾아야한다. 방법으로는 변수를 캡슐화하여 정해진 함수를 거쳐 값을 변경할 수 있도록 하거나 변수를 쪼개어 값 갱신 영향력을 줄인다. 또는 문장 슬라이드, 함수 추출하기를 이용하여 코드를 분리한다. 세터를 제거하여 변수 유효범위를 줄일 수 있다. 
<br />전역 데이터 악취도 굉장히 제거하기 힘든 악취이다. 어디서든 접근이 가능하기 때문에 참조/변경 지점을 찾기 어렵기 때문이다. 변수 캡슐화하기로 해당 악취를 줄일 수 있다. 접근을 통제할 수 있기 때문에 접근 범위를 줄일 수 있고, 접근하는 부분들을 모니터링할 수 있기 때문에 영향력을 판단하기가 보다 편해지기 떄문이다.
<br /> 전역 데이터가 가변 데이터라면 다루기 어렵다. 이러한 악취는 파생 변수를 질의 함수로 변경하여 혼동을 줄인다. 또는 여러 함수를 클래스로 묶거나 여러 함수를 변환함수로 변경하여 유효범위를 제한하는 방법도 선택할 수 있다.
		
		
		



